#### Back-End

### 1. Java

##### 1. Java의 특징
```
(1) 객체지향 프로그래밍(Object-Oriented Programming) : 코드의 재사용, 유지보수, 중복제거, 오작동 방지(클래스, 객체, 캡슐화, 다형성, 추상화)
(2) 자동 메모리 관리(Garbage Collection) : Garbage Collector를 통한 메모리 관리
(3) 독립적인 운영체제(JVM) : 자바 프로그램은 JVM을 통해 동작하기 때문에, 운영체제에 독립적임. 단, JVM이 운영체제에 종속적임.
(4) 멀티쓰레드(Multi Tread) : 다양한 쓰레드 영역을 시스템에 관게 없이 JAVA API를 활용해 구현이 가능함.
(5) 동적 로딩(Dynamic Loading) : 자바 프로그램 실행 시, 모든 클래스를 수행하지 않고 필요한 시점에서 클래스를 로딩함. 적은 자원으로 변경사항에 따른 유지보수 가능.
(6) 네트워크와 분산처리 : Java API를 사용해 인터넷의 방대한 분산처리 가능.
```
##### 2. Java Thread와 Process의 차이
```
(1) Process : JVM이 시작될 때 생성되며, JVM이 종료될 때 까지 계속 존재함(JVM 자체)
(2) Thread : JVM 내에서 실행되는 개별적인 실행 흐름(병렬로 실행되는 각각의 작업 단위)
```

##### 3. Solid 원칙
```
(1) S (Single Responsibility) : 단일책임의 원칙, 하나의 클래스는 하나의 책임을 가진다.
(2) O (Open/Closed) : 클래스는 확장은 열려있고 수정은 닫혀야한다. 기존 코드를 변경하지 않고 기능을 수정해야 한다.
(3) L (Liskov Substitution) : 상속과 다형성, 하위 클래스는 상위 클래스의 인스턴스를 대체할 수 있어야 함.
(4) I (Interface Segregation) : 클래스가 필요로하는 구체적이고 작은 여러가지 인터페이스로 세분화하는 것이 바람직함. 
(5) D (Dependency Inversion) : 유연성과 확장성을 위해서 구체적인 구현보다 인터페이스나 추상 클래스에 의존해야 함.
```
##### 4. Java의 자료구조(Data Structure)
```
(1) 배열(Array) : 고정된 크기의 연속된 메모리 공간에 동일한 데이터 타입을 저장
 - 인덱스 기반의 빠른 접근
 - 크기 변경이 어려움
(2) 리스트(List) : 순서를 유지하며 객체를 저장하는 집합
 - 동적 크기
 - 중복데이터 허용
 - 구현체 : ArrayList, LinkedList 등
(3) 셋(Set) : 중복을 허용하지 않는 객체의 집합
 - 집합 연산(합집합, 교집합 등)
 - 구현체 : HashSet, LinkedHashSet, TreeSet 등
(4) 맵(Map) : 키-값 쌍으로 데이터를 저장, 중복을 비허용
 - 키를 통한 빠른 데이터 접근이 용이함.
 - 구현체 : HashMap, LinkedHashMap, TreeMap 등
(5) 큐(Queue) : FIFO방식으로 데이터를 저장
 - 데이터의 삭제 : 앞
 - 데이터의 추가 : 뒤
 - 구현체 : LinkedList (큐 인터페이스 구현), PriorityQueue 등
(6) 스택(Stack) : LIFO방식으로 데이터를 저장
 - 데이터의 추가, 삭제 : 뒤
 - 구현체 : Java 기본 라이브러리(Stack), 인터페이스(Deque)-ArraryDeque 등
(7) 트리(Tree) : 노드들이 서로 연결된 계층적 구조로 데이터를 저장
 - 노드 : 하나의 부모와 여러 자식
 - 탐색, 삽입, 삭제 연산이 로그시간에 이루어짐.
 - 구현체: TreeSet, TreeMap(이진 탐색 트리) 등
```
##### 5. Java의 동작원리
```
(1) 소스코드 작성 및 컴파일 : Java 소스파일에 코드를 작성하고 Java Compiler(javac)를 통해 소스코드를 바이트코드로 변환하여 .Class파일로 저장
(2) 클래스 로더 : JVM 시작 시, 클래스 로더 컴포넌트는 .Class 파일을 메모리에 로드
(3) 바이트코드 실행 : JVM의 실행 엔진이 로드된 바이트코드를 해석하고 실행하면, JIT(Just-In-Time) 컴파일러를 통해 바이트코드를 기계어로 변환하고 해당 코드를 플랫폼에서 실행
(4) 런타임 데이터 영역 : 실행결과를 멀티스레드 영역에 따라 런타임 데이터 영역에 저장
 - 메소드 영역 : 클래스, 메소드, 변수 정보 등
 - 힙 영역 : 객체와 배열이 생성되는 영역
 - 스택 영역 : 메소드의 호출과 로컬 변수 등
 - PC 레지스터 : 현재 실행 중인 JVM 명령의 주소를 저장
 - 네이티브 메소드 스택 : 네이티브 메소드의 정보를 저장
(5) Garbage Collection : Garbage Collector를 통해 메모리를 자동으로 관리
 - 사용되지 않는 객체를 메모리에서 제거해 힙 영역의 메모리를 회수함.
 - JVM에 의해 GC의 실행 시점이 결정됨.
 - 수동제어 : System.gc() 메소드 사용.
```

#### 6. 자바개발환경
```
(1) JVM(Java Vitural Machine) : 자바 어플리케이션을 실행하기 위한 가상 컴퓨터
(2) JRE(Java Runtime Environment) = JVM + 클래스라이브러리(Java API) : 자바실행환경
(3) JDK(Java Development Kit) = JRE + 개발에 필요한 실행파일 (Javac.exe 등) : 자바개발도구
```

#### 7. 객체지향프로그래밍
|No|개념|설명|
|---|---|---|
|1| **클래스** | - 설계도나 틀과 같은 역할을 한다. 속성(변수)와 행위(메서드)를 정의한다. 예: `public class Car { ... }` |
|2| **객체**| - 클래스를 기반으로 실체화된 인스턴스를 말한다. 메모리에 할당된 실체를 의미한다. - 예: `Car myCar = new Car();`|
|3| **캡슐화** | - 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용을 감추는 것. 외부에서는 해당 객체의 내부 구조나 동작 방식을 알 필요 없이 제공되는 인터페이스만을 사용하여 해당 객체를 조작한다. 예: `private` 키워드를 사용하여 변수에 직접 접근하는 것을 제한하고 `public` 메서드를 통해 접근한다. |
|4| **다형성** | - 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있게 하는 특성. |
|5| - **오버로딩**: 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 유형과 개수가 다르게 하는 것.|                                |
|6| - **오버라이딩**: 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것. 예: `Animal a = new Dog();` 여기서 `Dog`은 `Animal` 타입의 하위 클래스라고 가정.|
|7| **추상화** | - 복잡한 시스템을 간단한 개념으로 변환하는 프로세스. 필요한 속성과 행위만을 포함하여 개체를 정의하는 것. 예: `abstract class Animal { ... }` 여기서 `Animal`은 구체적인 동물을 나타내지 않지만, 동물에 대한 기본적인 특성을 갖는다.|

### 2. Database
1. RDBMS(Relational Database Management System)
- 관계형 데이터베이스 관리 시스템
```
(1) 테이블 구조 : 행(row)과 열(column) 구성
(2) 데이터 무결성 : 제약 조건(Constraints) 설정
(3) SQL 사용
(4) 데이터 동시성 : 여러 사용자가 동시에 DB로 엑세스 할 경우, 데이터의 일관성 및 무결성을 보장함
(5) 데이터베이스 정규화 : 데이터 중복 최소화 및 구조를 효과적으로 조직화 하는 과정,  무결성과 효율성이 목적, DB설계 과정에서 작업 수행
(6) 트랜잭션 관리 : 데이터 베이스 작업들이 모두 수행되거나 반대로 수행되지 않도록 관리해 일관성을 유지함
(7) 백업 및 복구 : 데이터 손실 및 장애 상황에서 데이터 복구 가능
```
2. ACID 특성
- 트랜잭션의 안정성과 무결성을 보장하기 위한 속성
```
(1) Atomicity(원자성) : 트랜잭션 작업은 모두 완료되거나 모두 취소되어야 한다.
(2) Consistency(일관성) : 트랜잭션이 성공적으로 완료된 후에는 데이터베이스가 일관된 상태를 유지해야 함.
(3) Isolation(독립성) : 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 함.
(4) Durability(영속성) : 트랜잭션이 성공적으로 완료된 후에는 결과가 영구적으로 저장되어야 함.
```
3. SQL과 NoSQL 데이터베이스의 차이
```
(1) SQL(관계형 데이터베이스) : 데이터를 Table형태로 저장하며, 관계와 스키마를 갖는다. 
 - MySQL, PostgreSQL, Oracle DB 
(2) NoSQL(비관계형 데이터베이스) : 여러 형식의 데이터 저장 방식을 지원하며 스키마가 유연하거나 없음
 - MongoDB(문서기반), Redis(Key-value 저장소), cassandra(Column 기반), Neo4j(그래프 기반)  
```

4. 데이터베이스 인덱스의 작동
```
(1) Index 정의: 데이터베이스의 특정 컬럼에 대한 포인터나 참조를 저장해 검색 속도를 빠르게 만드는 자료구조
(2) Index 효과 : 데이터의 전체 스캔 없이 원하는 데이터를 빠르게 찾아 검색 성능이 향상 됨.
```

5. 트랜잭션 데드락(DeadLock)
```
(1) 정의 : 두 개 이상의 트랜잭션이 특정 자원(데이터베이스의 행 또는 테이블)의 잠금을 획득하려고 할 때, 각 트랜잭션은 다른 트랜잭션에 의해 점유된 자원의 해제를 기다리면서 서로가 진행을 마칠 수 없는 상태.

(2) 발생 조건
   - 상호 배제(Mutual Exclusion): 한 자원은 한 번에 하나의 트랜잭션만이 사용할 수 있다.
   - 점유와 대기(Hold and Wait): 한 트랜잭션은 최소한 하나의 자원을 점유하면서 다른 트랜잭션에 의해 점유된 자원을 추가로 얻기 위해 대기한다.
   - 비선점(No Preemption): 다른 트랜잭션에 의해 이미 점유된 자원은 그 트랜잭션이 자원을 해제할 때까지 그 자원을 강제로 빼앗을 수 없다.
   - 순환 대기(Circular Wait): 대기하는 트랜잭션 세트에서 트랜잭션들이 순환적으로 다음 트랜잭션에 의해 점유된 자원을 대기하는 상태.

(3) 예방법
   - 트랜잭션의 잠금 획득 순서를 일관되게 관리하여 순환 대기를 방지한다.
   - 타임아웃을 설정하여 일정 시간 내에 자원을 획득하지 못하면 트랜잭션을 롤백한다.
   - 잠금의 범위나 지속 시간을 최소화하여 동시성을 높인다.
   - 데이터베이스 시스템의 내장된 데드락 감지 메커니즘을 활용하여 자동으로 데드락 상황을 해결한다.
```

### 3. WEB
##### 1. RESTful API 방식
```
HTTP 프로토콜 기반의 GET, POST, PUT, DELETE, PATCH 메서드를 사용해서 웹 리소스에 접근하고, 상태정보를 서버가 아닌 클라이언트가 유지하여 서버는 각 요청을 독립적으로 처리할 수 있게 하는 방식의 소프트웨어 인터페이스
``` 

### 4. Spring
##### 1. Spring의 특징

|No|Feature|Description|
|---|---|---|
|1| **IoC(Inversion of Control)** | 객체의 생성과 관리를 Spring 컨테이너가 담당,비즈니스로직 개발에 집중할 수 있음. |
|2| **AOP(Aspect-Oriented Programming)** | 횡단 관심사(Cross-cutting concerns)를 모듈화로 분리하여 코드의 중복을 최소화하고 재사용성을 향상시킴. |
|3| **데이터 액세스 지원** | JDBC, JPA, MyBatis 등 다양한 데이터베이스 액세스 기술을 지원하여 일관된 데이터 액세스 코드 작성. |
|4| **트랜잭션 관리** | 코드 기반이 아닌, 선언적 트랜잭션 관리를 지원 |
|5| **MVC 웹 모듈** | Spring MVC를 사용하여 유연하고 확장 가능한 웹 애플리케이션 구축. |
|6| **보안** | Spring Security를 통해 강력한 인증, 권한 부여, 공격으로부터의 보호 등 다양한 보안 기능. |
|7| **다양한 모듈 지원** | 메시징, 웹 소켓, 웹 플로우 등 다양한 모듈을 제공하여 확장 가능한 애플리케이션 개발. |
|8| **테스트 지원** | JUnit, TestNG 등과의 통합을 통해 쉽게 테스트 케이스를 작성하고 실행. |
##### 2. Spring Boot의 장점
|No|Feature|Description|
|---|---|---|
|1| **자동 설정(Auto Configuration)** | 기본적인 설정을 자동으로 제공|
|2| **스타터 템플릿(Starter Templates)** | 필요한 의존성 추가로 스프링 부트가 필요한 라이브러리를 구축해 초기 설정 시간을 단축. |
|3| **내장 웹 서버** | Tomcat, Jetty와 같은 웹 서버를 내장. |
|4| **노 코드 생성** | 코드 생성이나 XML 설정을 최소화한 프로젝트의 구조|
|5| **프로덕션 준비 도구** | 모니터링, 상태 확인, 외부 설정과 같은 프로덕션 레벨의 기능을 제공. |
|6| **마이크로서비스 지원** | Spring Cloud와의 통합을 통해 마이크로서비스 아키텍처 구축 지원. |
|7| **커뮤니티 활성화** | 활발한 커뮤니티와 다양한 플러그인 및 확장 기능을 제공. |
|8| **버전 관리의 용이성** | 스프링 부트는 의존성 버전 관리가 편리하고 사용자는 버전을 직접 관리하는 대신 스프링 부트의 버전을 업그레이드하면 연관된 라이브러리들도 함께 업그레이드가 가능함. |
##### 3. Spring MVC 패턴
|No|Component|Description|
|---|---|---|
|1| **Model** | 데이터와 비즈니스 로직을 처리, 주로 Service와 DAO(Domain Access Object)로 구성. |
|2| **View** | 사용자에게 보여지는 화면, 주로 JSP, Thymeleaf, FreeMarker 등의 템플릿 엔진을 사용하여 구현함. |
|3| **Controller** | 사용자의 요청을 받아 처리, 적절한 Model을 호출한 다음, 응답을 View로 전달하는 역할. |
|4| **DispatcherServlet** | 클라이언트의 요청을 받아 적절한 Controller에게 전달하는 중앙 조정자 역할, Spring MVC의 핵심 구성요소. |
|5| **HandlerMapping** | 클라이언트의 요청 URL을 해석하여 어떤 Controller의 어떤 메서드를 호출할지 결정하는 역할. |
|6| **ViewResolver** | Controller가 리턴한 문자열(뷰 이름)을 기반으로 실제 뷰 파일의 위치를 찾아주는 역할. |
|7| **HandlerAdapter** | HandlerMapping을 통해 선택된 Controller를 실행하는 역할. |
|8| **Form tags & Validation** | (추가요소)사용자 입력 폼을 만들거나 입력된 데이터의 유효성 검사를 수행하는 데 사용되는 태그 및 기능. |

##### 4. Build Tool
|No| Feature/Tool | Maven | Gradle |
|---|---|---|---|
|1| **기반 언어** | XML | Groovy 또는 Kotlin |
|2| **성능** | 전통적으로 Gradle보다 느림 | 빠른 빌드 성능 및 캐싱 기능 제공 |
|3| **유연성** | 제한적인 XML 기반의 설정 제공 | 스크립트 기반으로 높은 유연성 제공 |
|4| **생태계** | 오래된 도구로서 광범위한 플러그인 및 라이브러리 지원 | 활발하게 성장하는 생태계와 플러그인 지원 |
|5| **빌드 생명주기** | 표준화된 빌드 생명주기 제공 | 사용자 정의 빌드 생명주기 가능 |
|6| **종속성 관리** | 중앙 저장소를 통한 종속성 관리 | 동적 버전 관리 및 종속성 캐싱 기능 제공 |
|7| **학습 곡선** | 상대적으로 더 단순하고 쉽게 시작 가능 | 초기 학습에는 더 많은 시간이 소요될 수 있으나, 높은 유연성 제공 |
|8| **통합 도구** | 대부분의 IDE와 통합 지원 | IntelliJ IDEA, Eclipse 등 주요 IDE와 통합 지원 |

### 5. 배포
#### 1-1. Web Deployment

|No|Feature|Description|
|---|---|---|
|1| **접근성**| 웹 브라우저만 있으면 어디서나 접근 가능.|
|2| **업데이트**| 서버 측에서만 업데이트하면 모든 사용자에게 즉시 반영됨.|
|3| **호환성**| 다양한 웹 브라우저와 버전을 고려해야 함.|
|4| **설치**| 사용자가 별도로 설치할 필요가 없음.|
|5| **접근 제한**| 웹 방화벽, HTTPS, 인증 메커니즘 등을 통한 보안이 필요.|
|6| **종속성 관리**| 서버 측에서 종속성을 관리. CDN, 웹팩 등의 도구를 사용해 최적화.|
|7| **퍼포먼스 최적화**| 캐싱, CDN, 압축, 브라우저 최적화 등 다양한 전략이 필요.|
|8| **가용성 및 확장성**| 서버와 데이터베이스의 가용성과 확장성을 고려해야 함. 클라우드 솔루션 등의 인프라 선택이 중요.|

#### 1-2. Web Deployment 관련 라이브러리 및 프레임워크
| 카테고리| 라이브러리/프레임워크|
|---|---|
| **웹 프레임워크**| Spring Boot, Java EE/Jakarta EE, Vert.x, Spark Java|
| **데이터베이스 연결**  | Hibernate, JPA, MyBatis|
| **보안**| Spring Security, Java EE Security API|
| **서버**| Tomcat, Jetty, WildFly, GlassFish|
| **빌드 및 배포 도구** | Maven, Gradle|
| **CI/CD**| Jenkins, Travis CI, CircleCI|
| **컨테이너화**| Docker, Kubernetes|
| **API 문서화**| Swagger/OpenAPI      

#### 2-1. Software Deployment

|No|Feature|Description|
|---|---|---|
|1| **접근성**| 특정 운영 체제나 플랫폼에 설치 후 사용.|
|2| **업데이트**| 사용자는 새로운 버전을 다운로드하거나 업데이트를 진행해야 함.|
|3| **호환성**| 대상 OS나 플랫폼의 버전과의 호환성을 검사해야 함.|
|4| **설치**| 설치 프로세스가 필요하며, 종종 설치자(installer)를 사용.|
|5| **접근 제한**| 소프트웨어 자체의 인증 또는 라이선스 메커니즘으로 접근을 제한.|
|6| **종속성 관리**| 사용자 시스템에 필요한 라이브러리나 모듈을 포함하거나, 별도로 설치하도록 안내 필요.|
|7| **퍼포먼스 최적화**| OS와 하드웨어 리소스를 최적으로 활용하는 최적화 전략 필요.|
|8| **가용성**| 사용자의 기기 및 환경에서 안정적으로 실행되어야 함.|

#### 2-2. Software Deployment 관련 라이브러리 및 프레임워크
|카테고리|라이브러리/프레임워크|
|---|---|
| **데스크톱 앱**| JavaFX, Swing, AWT|
| **데이터베이스 연결**| SQLite, H2, Derby (JavaDB)|
| **빌드 및 패키징**| Maven, Gradle, JPackage (Java 14+ for packaging native apps)|
| **인증 및 보안**| Java KeyStore, BouncyCastle|
| **외부 서비스 통신** | Java HTTP Client, OkHttp, Retrofit|
| **최적화 도구**| Java Profiler (e.g., VisualVM, YourKit)|
| **로깅**| Log4j, SLF4J, Logback|
| **배포 도구**| Install4J, Launch4j, Inno Setup 

### 6. ORM(Object-Relational Mapping)
- DB의 Table과 프로그래밍 언어의 객체를 매핑하는 프로그래밍 기법.
- 객체지향 프로그래밍에서 DB를 효율적이고 간결하게 처리할 수 있음.
1. JPA(Java Persistence API)
```
(1) Java에서 제공하는 ORM 표준 명세.
(2) 인터페이스의 집합으로 제공됨.
(3) 사용을 위해 구현체가 필요함.
```

### 7. Security
1. Spring Security

|No|Feature|Description|
|--------|------|----------------|
|1| **인증 (Authentication)** | 사용자의 아이디와 비밀번호를 통해 확인. `AuthenticationProvider` 구현을 통해 진행되며, 결과는 `SecurityContextHolder`에 저장. |
|2| **인가 (Authorization)**   | 인증된 사용자가 자원에 접근하거나 작업을 수행할 권한을 확인. `@PreAuthorize`, `@PostAuthorize`, `@Secured` 등의 어노테이션을 사용. |
|3| **CSRF 보호**| 웹 폼에 토큰을 추가하여 CSRF 공격으로부터 애플리케이션을 보호.|
|4| **세션 관리**| 사용자 세션을 효과적으로 관리하며, 동일 사용자의 여러 세션 제한이나 세션 만료 리다이렉트 등의 기능을 제공.|
|5| **비밀번호 인코딩**| 다양한 비밀번호 인코딩 메커니즘 (예: BCrypt, SCrypt)을 통해 저장된 비밀번호의 보안을 강화.|
|6| **OAuth2 & OpenID Connect** | OAuth2와 OpenID Connect를 지원하여 다양한 서드파티 인증 제공자와의 통합이 가능함.|
|7| **필터 기반 구조**| HTTP 요청과 응답 처리를 위한 필터 기반의 보안 작업을 수행.|
2. JWT

|No| Feature|Description|
|---|---|---|
|1|**정의**| JSON Web Token. JSON 객체를 사용하여 정보를 안전하게 전송하는 방식.|
|2|**구성**| Header, Payload, Signature의 3부분으로 구성됨. |
|3|**Header**| 토큰의 유형 (예: JWT) 및 사용되는 알고리즘 (예: HMAC SHA256 또는 RSA)을 지정하는 데 사용되는 부분. |
|4| **Payload** | 토큰에 포함된 클레임 (즉, 정보)을 포함. 이 클레임은 이름과 값의 쌍으로 구성됨.|
|5| **Signature**| Header와 Payload의 값을 비밀 키를 사용하여 암호화하는 데 사용됨. 이것은 토큰의 무결성을 검증하는 데 중요.|
|6| **사용 사례** | 인증 및 인가, 정보 교환, 세션 관리 등.|
|7| **보안**| Signature는 토큰의 내용이 변경되지 않았음을 검증하는 데 사용. 하지만 Payload 내용은 기본적으로 암호화되지 않으므로 중요한 정보는 JWT 내에 직접 포함하지 않는 것이 좋음. 필요한 경우 전체 토큰을 암호화할 수 있음.|
