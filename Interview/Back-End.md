#### Back-End

### 1. Java

##### 1. Java의 특징
```
(1) 객체지향 프로그래밍(Object-Oriented Programming) : 코드의 재사용, 유지보수, 중복제거, 오작동 방지(클래스, 객체, 캡슐화, 다형성, 추상화)
(2) 자동 메모리 관리(Garbage Collection) : Garbage Collector를 통한 메모리 관리
(3) 독립적인 운영체제(JVM) : 자바 프로그램은 JVM을 통해 동작하기 때문에, 운영체제에 독립적임. 단, JVM이 운영체제에 종속적임.
(4) 멀티쓰레드(Multi Tread) : 다양한 쓰레드 영역을 시스템에 관게 없이 JAVA API를 활용해 구현이 가능함.
(5) 동적 로딩(Dynamic Loading) : 자바 프로그램 실행 시, 모든 클래스를 수행하지 않고 필요한 시점에서 클래스를 로딩함. 적은 자원으로 변경사항에 따른 유지보수 가능.
(6) 네트워크와 분산처리 : Java API를 사용해 인터넷의 방대한 분산처리 가능.
```
##### 2. Java Thread와 Process의 차이
```
(1) Process : JVM이 시작될 때 생성되며, JVM이 종료될 때 까지 계속 존재함(JVM 자체)
(2) Thread : JVM 내에서 실행되는 개별적인 실행 흐름(병렬로 실행되는 각각의 작업 단위)
```

##### 3. Solid 원칙
```
(1) S (Single Responsibility) : 단일책임의 원칙, 하나의 클래스는 하나의 책임을 가진다.
(2) O (Open/Closed) : 클래스는 확장은 열려있고 수정은 닫혀야한다. 기존 코드를 변경하지 않고 기능을 수정해야 한다.
(3) L (Liskov Substitution) : 상속과 다형성, 하위 클래스는 상위 클래스의 인스턴스를 대체할 수 있어야 함.
(4) I (Interface Segregation) : 클래스가 필요로하는 구체적이고 작은 여러가지 인터페이스로 세분화하는 것이 바람직함. 
(5) D (Dependency Inversion) : 유연성과 확장성을 위해서 구체적인 구현보다 인터페이스나 추상 클래스에 의존해야 함.
```
##### 4. Java의 자료구조(Data Structure)
```
(1) 배열(Array) : 고정된 크기의 연속된 메모리 공간에 동일한 데이터 타입을 저장
 - 인덱스 기반의 빠른 접근
 - 크기 변경이 어려움
(2) 리스트(List) : 순서를 유지하며 객체를 저장하는 집합
 - 동적 크기
 - 중복데이터 허용
 - 구현체 : ArrayList, LinkedList 등
(3) 셋(Set) : 중복을 허용하지 않는 객체의 집합
 - 집합 연산(합집합, 교집합 등)
 - 구현체 : HashSet, LinkedHashSet, TreeSet 등
(4) 맵(Map) : 키-값 쌍으로 데이터를 저장, 중복을 비허용
 - 키를 통한 빠른 데이터 접근이 용이함.
 - 구현체 : HashMap, LinkedHashMap, TreeMap 등
(5) 큐(Queue) : FIFO방식으로 데이터를 저장
 - 데이터의 삭제 : 앞
 - 데이터의 추가 : 뒤
 - 구현체 : LinkedList (큐 인터페이스 구현), PriorityQueue 등
(6) 스택(Stack) : LIFO방식으로 데이터를 저장
 - 데이터의 추가, 삭제 : 뒤
 - 구현체 : Java 기본 라이브러리(Stack), 인터페이스(Deque)-ArraryDeque 등
(7) 트리(Tree) : 노드들이 서로 연결된 계층적 구조로 데이터를 저장
 - 노드 : 하나의 부모와 여러 자식
 - 탐색, 삽입, 삭제 연산이 로그시간에 이루어짐.
 - 구현체: TreeSet, TreeMap(이진 탐색 트리) 등
```
##### 5. Java의 동작원리
```
(1) 소스코드 작성 및 컴파일 : Java 소스파일에 코드를 작성하고 Java Compiler(javac)를 통해 소스코드를 바이트코드로 변환하여 .Class파일로 저장
(2) 클래스 로더 : JVM 시작 시, 클래스 로더 컴포넌트는 .Class 파일을 메모리에 로드
(3) 바이트코드 실행 : JVM의 실행 엔진이 로드된 바이트코드를 해석하고 실행하면, JIT(Just-In-Time) 컴파일러를 통해 바이트코드를 기계어로 변환하고 해당 코드를 플랫폼에서 실행
(4) 런타임 데이터 영역 : 실행결과를 멀티스레드 영역에 따라 런타임 데이터 영역에 저장
 - 메소드 영역 : 클래스, 메소드, 변수 정보 등
 - 힙 영역 : 객체와 배열이 생성되는 영역
 - 스택 영역 : 메소드의 호출과 로컬 변수 등
 - PC 레지스터 : 현재 실행 중인 JVM 명령의 주소를 저장
 - 네이티브 메소드 스택 : 네이티브 메소드의 정보를 저장
(5) Garbage Collection : Garbage Collector를 통해 메모리를 자동으로 관리
 - 사용되지 않는 객체를 메모리에서 제거해 힙 영역의 메모리를 회수함.
 - JVM에 의해 GC의 실행 시점이 결정됨.
 - 수동제어 : System.gc() 메소드 사용.
```

#### 6. 자바개발환경
```
(1) JVM(Java Vitural Machine) : 자바 어플리케이션을 실행하기 위한 가상 컴퓨터
(2) JRE(Java Runtime Environment) = JVM + 클래스라이브러리(Java API) : 자바실행환경
(3) JDK(Java Development Kit) = JRE + 개발에 필요한 실행파일 (Javac.exe 등) : 자바개발도구
```

### 2. Database
1. RDBMS(Relational Database Management System)
- 관계형 데이터베이스 관리 시스템
```
(1) 테이블 구조 : 행(row)과 열(column) 구성
(2) 데이터 무결성 : 제약 조건(Constraints) 설정
(3) SQL 사용
(4) 데이터 동시성 : 여러 사용자가 동시에 DB로 엑세스 할 경우, 데이터의 일관성 및 무결성을 보장함
(5) 데이터베이스 정규화 : 데이터 중복 최소화 및 구조를 효과적으로 조직화 하는 과정,  무결성과 효율성이 목적, DB설계 과정에서 작업 수행
(6) 트랜잭션 관리 : 데이터 베이스 작업들이 모두 수행되거나 반대로 수행되지 않도록 관리해 일관성을 유지함
(7) 백업 및 복구 : 데이터 손실 및 장애 상황에서 데이터 복구 가능
```
2. ACID 특성
- 트랜잭션의 안정성과 무결성을 보장하기 위한 속성
```
(1) Atomicity(원자성) : 트랜잭션 작업은 모두 완료되거나 모두 취소되어야 한다.
(2) Consistency(일관성) : 트랜잭션이 성공적으로 완료된 후에는 데이터베이스가 일관된 상태를 유지해야 함.
(3) Isolation(독립성) : 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 함.
(4) Durability(영속성) : 트랜잭션이 성공적으로 완료된 후에는 결과가 영구적으로 저장되어야 함.
```
3. SQL과 NoSQL 데이터베이스의 차이
```
(1) SQL(관계형 데이터베이스) : 데이터를 Table형태로 저장하며, 관계와 스키마를 갖는다. 
 - MySQL, PostgreSQL, Oracle DB 
(2) NoSQL(비관계형 데이터베이스) : 여러 형식의 데이터 저장 방식을 지원하며 스키마가 유연하거나 없음
 - MongoDB(문서기반), Redis(Key-value 저장소), cassandra(Column 기반), Neo4j(그래프 기반)  
```

4. 데이터베이스 인덱스의 작동
```
(1) Index 정의: 데이터베이스의 특정 컬럼에 대한 포인터나 참조를 저장해 검색 속도를 빠르게 만드는 자료구조
(2) Index 효과 : 데이터의 전체 스캔 없이 원하는 데이터를 빠르게 찾아 검색 성능이 향상 됨.
```

5. 트랜잭션 데드락(DeadLock)
```
(1) 정의 : 두 개 이상의 트랜잭션이 특정 자원(데이터베이스의 행 또는 테이블)의 잠금을 획득하려고 할 때, 각 트랜잭션은 다른 트랜잭션에 의해 점유된 자원의 해제를 기다리면서 서로가 진행을 마칠 수 없는 상태.

(2) 발생 조건
   - 상호 배제(Mutual Exclusion): 한 자원은 한 번에 하나의 트랜잭션만이 사용할 수 있다.
   - 점유와 대기(Hold and Wait): 한 트랜잭션은 최소한 하나의 자원을 점유하면서 다른 트랜잭션에 의해 점유된 자원을 추가로 얻기 위해 대기한다.
   - 비선점(No Preemption): 다른 트랜잭션에 의해 이미 점유된 자원은 그 트랜잭션이 자원을 해제할 때까지 그 자원을 강제로 빼앗을 수 없다.
   - 순환 대기(Circular Wait): 대기하는 트랜잭션 세트에서 트랜잭션들이 순환적으로 다음 트랜잭션에 의해 점유된 자원을 대기하는 상태.

(3) 예방법
   - 트랜잭션의 잠금 획득 순서를 일관되게 관리하여 순환 대기를 방지한다.
   - 타임아웃을 설정하여 일정 시간 내에 자원을 획득하지 못하면 트랜잭션을 롤백한다.
   - 잠금의 범위나 지속 시간을 최소화하여 동시성을 높인다.
   - 데이터베이스 시스템의 내장된 데드락 감지 메커니즘을 활용하여 자동으로 데드락 상황을 해결한다.
```

### 3. WEB
##### 1. RESTful API 방식
```
HTTP 프로토콜 기반의 GET, POST, PUT, DELETE, PATCH 메서드를 사용해서 웹 리소스에 접근하고, 상태정보를 서버가 아닌 클라이언트가 유지하여 서버는 각 요청을 독립적으로 처리할 수 있게 하는 방식의 소프트웨어 인터페이스
``` 

### 4. Spring
##### 1. Spring의 특징

|No|Feature|Description|
|---|---|---|
|1| **IoC(Inversion of Control)** | 객체의 생성과 관리를 Spring 컨테이너가 담당,비즈니스로직 개발에 집중할 수 있음. |
|2| **AOP(Aspect-Oriented Programming)** | 횡단 관심사(Cross-cutting concerns)를 모듈화로 분리하여 코드의 중복을 최소화하고 재사용성을 향상시킴. |
|3| **데이터 액세스 지원** | JDBC, JPA, MyBatis 등 다양한 데이터베이스 액세스 기술을 지원하여 일관된 데이터 액세스 코드 작성. |
|4| **트랜잭션 관리** | 코드 기반이 아닌, 선언적 트랜잭션 관리를 지원 |
|5| **MVC 웹 모듈** | Spring MVC를 사용하여 유연하고 확장 가능한 웹 애플리케이션 구축. |
|6| **보안** | Spring Security를 통해 강력한 인증, 권한 부여, 공격으로부터의 보호 등 다양한 보안 기능. |
|7| **다양한 모듈 지원** | 메시징, 웹 소켓, 웹 플로우 등 다양한 모듈을 제공하여 확장 가능한 애플리케이션 개발. |
|8| **테스트 지원** | JUnit, TestNG 등과의 통합을 통해 쉽게 테스트 케이스를 작성하고 실행. |
##### 2. Spring Boot의 장점
|No|Feature|Description|
|---|---|---|
|1| **자동 설정(Auto Configuration)** | 기본적인 설정을 자동으로 제공|
|2| **스타터 템플릿(Starter Templates)** | 필요한 의존성 추가로 스프링 부트가 필요한 라이브러리를 구축해 초기 설정 시간을 단축. |
|3| **내장 웹 서버** | Tomcat, Jetty와 같은 웹 서버를 내장. |
|4| **노 코드 생성** | 코드 생성이나 XML 설정을 최소화한 프로젝트의 구조|
|5| **프로덕션 준비 도구** | 모니터링, 상태 확인, 외부 설정과 같은 프로덕션 레벨의 기능을 제공. |
|6| **마이크로서비스 지원** | Spring Cloud와의 통합을 통해 마이크로서비스 아키텍처 구축 지원. |
|7| **커뮤니티 활성화** | 활발한 커뮤니티와 다양한 플러그인 및 확장 기능을 제공. |
|8| **버전 관리의 용이성** | 스프링 부트는 의존성 버전 관리가 편리하고 사용자는 버전을 직접 관리하는 대신 스프링 부트의 버전을 업그레이드하면 연관된 라이브러리들도 함께 업그레이드가 가능함. |
##### 3. Spring MVC 패턴
|No|Component|Description|
|---|---|---|
|1| **Model** | 데이터와 비즈니스 로직을 처리, 주로 Service와 DAO(Domain Access Object)로 구성. |
|2| **View** | 사용자에게 보여지는 화면, 주로 JSP, Thymeleaf, FreeMarker 등의 템플릿 엔진을 사용하여 구현함. |
|3| **Controller** | 사용자의 요청을 받아 처리, 적절한 Model을 호출한 다음, 응답을 View로 전달하는 역할. |
|4| **DispatcherServlet** | 클라이언트의 요청을 받아 적절한 Controller에게 전달하는 중앙 조정자 역할, Spring MVC의 핵심 구성요소. |
|5| **HandlerMapping** | 클라이언트의 요청 URL을 해석하여 어떤 Controller의 어떤 메서드를 호출할지 결정하는 역할. |
|6| **ViewResolver** | Controller가 리턴한 문자열(뷰 이름)을 기반으로 실제 뷰 파일의 위치를 찾아주는 역할. |
|7| **HandlerAdapter** | HandlerMapping을 통해 선택된 Controller를 실행하는 역할. |
|8| **Form tags & Validation** | (추가요소)사용자 입력 폼을 만들거나 입력된 데이터의 유효성 검사를 수행하는 데 사용되는 태그 및 기능. |
##### 4. Build Tool
|No| Feature/Tool | Maven | Gradle |
|---|---|---|---|
|1| **기반 언어** | XML | Groovy 또는 Kotlin |
|2| **성능** | 전통적으로 Gradle보다 느림 | 빠른 빌드 성능 및 캐싱 기능 제공 |
|3| **유연성** | 제한적인 XML 기반의 설정 제공 | 스크립트 기반으로 높은 유연성 제공 |
|4| **생태계** | 오래된 도구로서 광범위한 플러그인 및 라이브러리 지원 | 활발하게 성장하는 생태계와 플러그인 지원 |
|5| **빌드 생명주기** | 표준화된 빌드 생명주기 제공 | 사용자 정의 빌드 생명주기 가능 |
|6| **종속성 관리** | 중앙 저장소를 통한 종속성 관리 | 동적 버전 관리 및 종속성 캐싱 기능 제공 |
|7| **학습 곡선** | 상대적으로 더 단순하고 쉽게 시작 가능 | 초기 학습에는 더 많은 시간이 소요될 수 있으나, 높은 유연성 제공 |
|8| **통합 도구** | 대부분의 IDE와 통합 지원 | IntelliJ IDEA, Eclipse 등 주요 IDE와 통합 지원 |

### 5. 배포
```
```

### 6. ORM
```
(1) JPA
```

### 7. Security
```
(1) Spring Security
(2) JWT
```

